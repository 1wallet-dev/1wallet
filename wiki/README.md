**DRAFT v0.0.8** | 2020-05-13

[1-Page Project Summary](http://harmony.one/1wallet)

[Demo & Code](https://github.com/hashmesan/harmony-totp)

[Harmony's Wallet Strategy](https://twitter.com/stse/status/1390810619834638336)

[Reference & Discussion](https://docs.google.com/document/d/1Ojyjm1MDT3CPHCOw36pCUQTSyRVdTI8XnEOb0m1VZkk/edit#heading=h.sbj5y85h1hg8)


## Table of Contents

* [Table of Contents](#table-of-contents)

* [Overview](#overview)
* [Technical Background](#technical-background)
    * [Challenges with Two\-factor Authentication (2FA) on Blockchain](#challenges-with-two-factor-authentication-2fa-on-blockchain)
    * [SmartOTP](#smartotp)
        * [Key issues for adoption](#key-issues-for-adoption)
        * [Notations](#notations)
        * [Assumptions](#assumptions)
        * [Security](#security)
* [ONE Wallet Technical Design](#one-wallet-technical-design)
    * [Context](#context)
    * [Components](#components)
        * [Client](#client)
            * [OTP Seed](#otp-seed)
            * [OTP](#otp)
            * [OTP Merkle Tree](#otp-merkle-tree)
            * [OTP Proof](#otp-proof)
            * [Visibility of OTP Merkle Tree](#visibility-of-otp-merkle-tree)
            * [Enhanced Security Mode](#enhanced-security-mode)
        * [Authenticator](#authenticator)
            * [OTP Seed](#otp-seed-1)
            * [OTP](#otp-1)
        * [Smart Contract](#smart-contract)
    * [Operations](#operations)
        * [Creating Wallet](#creating-wallet)
        * [Transfer Funds](#transfer-funds)
            * [Small Transfer](#small-transfer)
            * [Large Transfer](#large-transfer)
        * [Guardian](#guardian)
            * [Add](#add)
            * [Remove](#remove)
        * [Drain Funds](#drain-funds)
        * [(TODO) Social Authentication](#todo-social-authentication)
    * [Security](#security-1)
    * [Open Problems](#open-problems)


## Overview

ONE Wallet is a non-custodial crypto wallet optimized for everyday use cases. It is designed to be more secure and easier to use than existing crypto wallets and engineered to be more resilient to theft and accidental loss. Users can send payments as efficiently and securely as Venmo, Paypal, or Coinbase Wallet, and recover funds when they forget passwords. However, as a non-custodial wallet operating on smart contracts, the user would retain all control rather than being forced to trust a company or a person and give up all control to them.

ONE Wallet is one of the first non-custodial wallets to support Google authenticator, social recovery, and multi-layer authentication. The wallet will support major cryptocurrencies such as ETH, ONE, BSC, BTC, ATOM, and others. By design, the wallet requires two-factor authentications for sensitive operations. The funds in the wallet remain safe even if hackers gained control of a single device (e.g., wallet client on a computer). If the user loses their passwords or private keys, the wallet provides multiple mechanisms for fund recovery.

Features:

- Smart-contract wallet: open-source, transparent, entirely controlled by the user, using algorithms audited by the community.
- Establish ownership by social identities (e.g., Twitter), not just private keys
- Multiple layers of security (optional):
    - **Quick transfer**: Send a small amount of fund (e.g., $100) using a random 6-digit code generated by Google Authenticator
    - **Spending limit**: Control spending with a daily limit
    - **Fund recovery**: Set the last resort address for fund recovery so you would not lose all your funds even in the worst case
    - **Guardians**: Invite others to guard your wallet: establish identities, recover accounts, authorize sensitive transactions
    - **Multi-factor authentication**: Authorize sensitive operations (e.g., sending $100000, destroy wallet, adding/removing identities) using multiple mechanisms together (e.g., Twitter + Google Authenticator code + Guardian)


[One Pager](http://harmony.one/1wallet) | [Roadmap](https://docs.google.com/document/d/1Ojyjm1MDT3CPHCOw36pCUQTSyRVdTI8XnEOb0m1VZkk/edit#heading=h.b6hs847sk2vn) | [Discussions](https://docs.google.com/document/d/1Ojyjm1MDT3CPHCOw36pCUQTSyRVdTI8XnEOb0m1VZkk/edit#heading=h.sbj5y85h1hg8)

ONE Wallet runs on Harmony network, a fast blockchain based on proof-of-stakes consensus. It is compatible with apps that run on Ethereum, but substantially outperforms Ethereum in many ways (most significantly, fees and consensus time).

## Technical Background

### Challenges with Two-factor Authentication (2FA) on Blockchain

After two decades of security incidents, password leaks, and privacy movements, two-factor authentication and one-time password (OTP) already became ubiquitous in non-blockchain applications. Today, an app that does not have 2FA implemented may be considered insecure and look out of place. Among 2FA implementations, Google Authenticator (GA) is arguably the most popular method for generating an OTP (aside from sending OTP by text messages). With GA, a 6-digit code<sup>[1](#f1)</sup> OTP is generated using the current timestamp and a secret seed. The code remains valid for 30 seconds, aftwards a new code is generated. The seed is typically generated and stored by the app's server, displayed on the screen as a QR code, then transmitted by the user to the GA app by a camera scan. The QR code encodes the seed itself and some configuration parameters. The seed is permanently stored on GA and can be exported by the user at any time. The server can validate a user's identity by verifying whether the user is providing an expected QR code.

On a public blockchain, the role of a server is replaced by the smart contract, where the execution code and parameters are visible to the public by default. Therefore, we can no longer store the secret seed can on-chain. Otherwise, the seed would be visible to everyone. The challenge is to find a way to verify an OTP is valid at a given time without exposing any secret while assuming all execution data are visible to attackers. On top of that, the design must consider potential delays in blockchain consensus and blockchain's execution and storage cost.

<a name="f1">[1]</a> Although the iOS version supports 8-digit code, more secure algorithms, and additional options such as generating a new-code every 60 seconds instead of 30 seconds, the Android version only supports the most basic algorithm with 6-digit code. See an [in-depth analysis by Laban Sk√∂llermark](https://labanskoller.se/blog/2019/07/11/many-common-mobile-authenticator-apps-accept-qr-codes-for-modes-they-dont-support/)

### SmartOTP

Our design extends from the groundwork laid by [SmartOTP (Homoliak et al., 2018)](https://arxiv.org/abs/1812.03598). SmartOTP proposes a smart contract wallet that requires each operation to be confirmed by two factors: a signature generated by a private key (to initiate the operation) and an OTP generated by an authenticator. The signature-confirmation component is similar to how users authorize transactions on mainstream wallets (e.g., MetaMask). The OTP component is new, and it may be the first to explore the use of OTP in the context of a smart contract without using any oracle. Compared to MetaMask, the OTP mechanism adds an extra layer of security. In practice, it is cumbersome to ask the users to confirm every operation. Something as trivial as paying \$20 to a friend for lunch should be frictionless.

#### Key issues for adoption

Overall, there are several major obstacles in adopting SmartOTP:

1. The OTP is not a time-based OTP similar to that of Google Authenticator. Generating an OTP requires an operation ID as an input parameter instead of the current time.
2. The OTP is very long (at least 128-bit, compared to 20-bit for a 6-digit code in Google Authenticator).
3. The authenticator computes the OTP based on a customized function of the input (the operation ID and the seed). [*](#issue-beta-function)
4. All operations must be initiated using a signature confirmation, marked as pending, then later confirmed by the OTP.
5. A separate hardware wallet is assumed to carry the private keys and perform signing (and authorization) of the initialization of an operation.

#### Notations

Using the notation in the paper, we have: a user **U**, a client-side program **C** (similar to MetaMask), a hardware wallet **W** (similar to Trezor), and the smart contract wallet **S** (the smart contracts holding the user's funds and perform a variety of operations). The hardware wallet maintains the private key and produces signatures for all transactions. For our use case, we consider the client **C** merged with the hardware wallet **W**, and refer them both together as **C**.

#### Assumptions

Following the assumptions in SmartOTP:

1. The secret seed for OTP is only stored and kept on the authenticator **A**.
2. The client keeps a copy of the seed only before creating the smart contract wallet **S**.
3. When the wallet is created, the client generates a large number of OTPs with seed. These OTPs are then hashed and built into a Merkle tree<sup>[2](#f2)</sup>. The hashed values are kept in client **C** only. They will be used in computing proofs for operations. The seed is discarded after the wallet is created.
4. The smart contract wallet **S** only keeps the root<sup>[3](#f3)</sup> of the Merkle tree created in (3). The roots are sufficient to verify whether an OTP is valid.

<a name="f2">[2]</a>: The paper also introduces several optimizations to reduce the number of hashes by several orders of magnitudes. As discussed below, they cannot be used with Google Authenticator, so we omit the details here.

<a name="f3">[3]</a>: The paper suggests caching a layer of nodes to reduce the compute cost in practice. This optimization is not essential in our use case as the gas cost on Harmony network is cheap.

#### Security

Under the above assumptions, SmartOTP offers excellent security. SmartOTP remains secure when only a single point is compromised. A compromised client cannot confirm any operation without the correct OTP. A compromised authenticator does not pose any risk because the attacker cannot initiate any operation without the private key at the wallet (or client, in the absensce<sup>[4](#f4)</sup> of hardware wallet). We omit the details since the paper provides excellent analysis for various scenarios, such as attacks intended to prevent the user from accessing the funds.

<a name="f4">[4]</a>: If the client is compromised and a software wallet is used (as part of the client), the attacker may still perform a front-running attack.


## ONE Wallet Technical Design

The core of ONE Wallet is the client **C** and the smart contract **S**. A proof-of-concept (work in progress) is made open source and [available on Github](https://github.com/hashmesan/harmony-totp). The authenticator is Google Authenticator. At this stage, we are leaving the design of the user interface and wrappers around the client **C** to the next stage of the project. We are open for other developers to contribute, or to build their own wallet based on our core.

### Context

Since ONE Wallet is based on a smart contract, it has to be deployed (thus created) by another account. This operation costs gas, and the gas has to be paid by that account. We refer to that account as the owner account **O**. The owner account can be an existing wallet under the user's control, or a contract account created by Harmony specifically designated for this purpose. In either case, we assume it already exists. If it is an account under the user's control, the user may use it for fund recovery. For example, the user may add owner account's address as a guardian or as a last-resort drain. The user may also use it to add an extra layer of security, since the owner account would have its own private key **P** which can be used to sign transactions and initiate operations similar to the design in SmartOTP.

At the next stage of development, we may generate and manage this wallet address on the user's behalf. But for now, we focus our discussion and analysis only on the client **C**, the smart contract **S**, and how the user **U** interact with them using their Google Authenticator **A**. We also limit our initial discussion and security analysis to the authentication and authorizations provided by authenticator **A**, as well as private key **P** and guardians in applicable scenarios. We will leave social login features to the next version. To address security concerns and issues identified in previous sections, we also introduce an enhanced security mode which makes uses of multiple OTPs and counter-based OTPs, in addition to the default settings which only a single time-based OTP is used.

In the sections below, we first define the elements the wallet uses in its operations and refer back to the SmartOTP paper if a similar element is used in the design of SmartOTP. Afterwards, we show how each elemenet is used in operations between the user and the wallet.

### Components

#### Client

The Client is the primary interface which the user may create and manage their ONE Wallet. The Client can be a native program running on an operating system, a browser extension, or a mobile app. The Client is assumed to be not easily compromised, thus any credentials and non-public constructs stored at the Client is assumed to be secure unless an attacker specifically targets the Client.

The Client holds constructs that are necessary to perform operations on the ONE Wallet. Some constructs are transient (e.g. OTP Seed) and must be destroyed as soon as they serve their purpose. Some constructs may become visible to the public over time (e.g. OTP Merkle Tree). We assume constructs such as owner account's private key **P** (if applicable) exists outside the Client in the current version. In later sections, we analyze the scenarios separately: the Client is compromised, the private key **P** is comrpomised, or both are compromised.

##### OTP Seed

OTP Seed is a random string generated by the Client and encoded in the QR code which is subsequently scanned by the user to initialize the Google Authenticator. The seed is destroyed after hashed values of potential OTPs are computed, **prior to** the creation of the wallet. Based on [RFC4226](https://www.ietf.org/rfc/rfc4226.txt) the secret seed must be at least 128-bit (16 characters long). The recommended length is 160-bit. In ONE Wallet we uses a random string of 160-bit long (20 characters).

Note that, in SmartOTP paper, the seed is generated by the Authenticator instead of the Client, and copied to Client in some air-gapped manner via QR Code (displayed on the authenticator) or a microSD card. We changed this mechanism because Google Authenticator cannot generate seed values on its own, and such change does not make the wallet less secure. If the Client is compromised during the creation of the wallet, the wallet would be compromised regardless of where the seed is generated.

##### OTP

OTP codes are generated and temporarily held at the Client only during the construction of OTP Merkle Tree, using exactly the same algorithms<sup>[6](#f6)</sup> the Authenticator would use. During OTP code generation, we enumerate possible input values (time or counter) for the OTP algorithms for a reasonably long foreseeble future. After the OTP Merkle Tree is generated, the OTPs are destroyed. The OTP codes themselves cannot be recovered from the Merkle Tree aside from using brute-force attacks. Since brute-force attacks on 1 million possible codes is trivially simple, if the OTP Merkle Tree is constructed using hashes of single OTP codes as leaves, the original OTP codes would be trivially recovered from the OTP Merkle Tree. In this scenario the OTP codes would not be able to offer an additional layer of security protection if the Client is compromised, sine the OTP Merkle Tree (see below) is stored in the Client. Nonethless, such OTP codes can still be useful in making small transfer convinient. See later sections for a detailed discussions. Additionally, our designs in the Enhanced Security Mode address this issue by grouping multiple OTPs together before they are hashed and used as leaves, thus makes brute-force attacks exceedingly difficult.

<a name="f6">[6]</a>: A [mathematical construction](https://www.wikiwand.com/en/HMAC-based_One-Time_Password) is provided on Wikipedia. A [step-by-step tutorial with code examples](https://hackernoon.com/how-to-implement-google-authenticator-two-factor-auth-in-javascript-091wy3vh3) are available at Hackernoon.

##### OTP Merkle Tree

OTP Merkle Tree is a merkle tree constructed using hashed values of all the OTP codes enumerated for the expected lifespan of the wallet. The construction process is same as a standard merkle tree: the hashed values of the enumerated OTP codes are placed as the leaves of the tree, and the inner nodes of the tree are the hash of the concatenation of the consecutive hash pair from the layer below, starting from the leaves.

##### OTP Proof

OTP Proof is a path from a leaf to the root of the OTP Merkle Tree, plus an OTP code itself. In SmartOTP, the OTP Merkle Tree is not assumed to be secret. The OTP Proof is submitted to the Smart Contract as part of the proof during OTP validation. This implies whenever an OTP is used in an operation submitted to the blockchain, its sibling and ancestors on the merkle-tree are exposed to the public. Since SmartOTP's custom Authenticator re-uses all OTP codes for multiple times (while maintaining security by leveraging hashchains), the OTP Merkle Tree is completely made public soon after all OTP codes are used at least once.

##### Visibility of OTP Merkle Tree

In our design, the OTP Merkle Tree is not necessarily made public. This is because of two key differences: (1) the OTPs generated by Google Authenticator are time-based, and (2) the OTPs are never re-used. Since each OTP code is valid for 30 seconds, we only need to generate about 1 million<sup>[7](#f7)</sup> codes to cover an one-year lifespan of a wallet. In all but the most extreme corner use cases, the user would not be using the wallet all the time during the lifespan of the wallet, hence only a very small portion of the 1 million OTP codes would be used. Since time monotonically increases, and we are unable to embed a custom function in the Authenticator (as mentioned in [previous section](#issue-beta-function)), we would not be following any pattern to reuse a OTP code that was used in previous operations<sup>[8](#f8)</sup>.

At any time an OTP Proof is submitted as proof and made public, only its immediate sibling and ancestors are made public. This means all other values on the leaves (i.e. the hashes of the OTPs) would remain undisclosed until a corresponding OTP or its sibling's corresponding OTP is used. Therefore, we may assume the OTP Merkle Tree is semi-private, and leverage this property in our design. For example, we may create a "shallow copy" of the wallet offering limited functionalities to be used in an insecure environment (e.g. work phone, work laptop, family-shared computer), by providing a copy of the OTP Merkle Tree and allow some operations to be authorized by using the tree and an OTP code.

<a name="f7">[7]</a>: 3600 seconds / 30 seconds * 24 hours/day * 365 days/year ~= 1 million codes / year

<a name="f8">[8]</a>: Collision to previously used code would still occur, since there are only 1,000,000 codes available for a 6-digit OTP code. However, such collision would not be based on any tractable pattern.


##### Enhanced Security Mode

In Enhanced Security Mode, we use one or more additional counter-based OTP Seeds to configure the Authenticator, and generate associated OTP Merkle Tree accordingly. Different security levels may require different numbers of conseuctive OTPs to be provided to confirm a transaction. Thus, the OTPs must be first grouped together into n-tuples before being hashed and used as the leaves to generate the Merkle Tree, where n is the number of consecutive OTPs required.

#### Authenticator

As discussed above, the Authenticator we use is a standard Google Authenticator that can be downloaded from [iOS](https://apps.apple.com/us/app/google-authenticator/id388497605) and [Android](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en_US&gl=US) stores. Because of the compatibility issues<sup>[1](#f1)</sup> described above in the Android version of the Google Authenticator, we limit the configuration parameters<sup>[9](#f9)</sup> to using 6-digit OTP code, SHA1 hash function, and time-based OTP code with a refreshing interval of 30-seconds.

Despite the shortcomings, both Android and iOS version of the Google Authenticator also support counter-based OTP code. Although our design is primarily based on time-based OTP codes, in later parts we also use counter-based OTP codes to enhance its security. When counter-based OTP codes are used, we will need to add additional OTP seed to the Authenticator by scanning additional QR codes.

<a name="f9">[9]</a>: See Google Authenticator [URI format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format) for a detailed description of possible parameters. The QR Code simply encodes the URI.

##### OTP Seed

The Authenticator acquires the OTP seed from the Client when a new wallet is created, by scanning a QR code which also conveys other configurations for the Authenticator. The seed is then permanently stored on the Authenticator until the user manually deletes it.

It should be noted that Google Authenticator allows the user to export the seed at any time. Therefore, we need to consider two kinds of threats in our security analysis: (1) an attacker who gains visibility into one or more OTP codes, and (2) an attacker who temporarily gains physical or remote access to the user's phone, therefore is able to gain visibility into the OTP seed itself.

In Enhanced Security Mode, counter-based OTPs are used in addition to time-based OTP. Extra OTP seeds  is stored on the Authenticator and the same analysis applies.

##### OTP

After the Authenticator is provided with OTP seed(s), the standard time-based OTPs are automatelly generated by Google Authenticator every 30 seconds (with an initial offset so to round off to nearest 30-second interval with respect to Unix epoch).

The counter-based OTPs used in Enhanced Security Mode are generated only by request from the user (by clicking a refresh button). The OTPs do not expire or refresh themselves, but they are automatically masked by Google Authenticator after a period of inactivity. Under the hood, each time the user refreshes the counter-based OTP, the counter is increased by one. The counter value is a private state inside the Authenticator. Since the user may refresh for an arbitrary number of times, the counter value may be different from what the Client and the Smart Contract anticipates. Therefore, the Client must look ahead and resynchronize<sup>[10](#f10)</sup> its own counter as well as the Smart Contract's, such that all three components would have consistent view of the counter value while verifying the OTP codes. This can be achieved easily at the Client since it possesses the hashed values of (groups of) OTPs (as part of the OTP Merkle Tree stored at the Client), and it may simply look ahead the hash values one-by-one and increment its internal counter until it finds a hash value that matches the hash of the OTP(s) provided by the user. Afterwards, the Client can submit the new counter value to the Smart Contract to achieve resynchronization at the Smart Contract.

<a name="f10">[10]</a>: See also a brief discussion in [RFC4224 Section 7.4 Resynchronization of the Counter](https://datatracker.ietf.org/doc/html/rfc4226#section-7.4)

#### Smart Contract

The Smart Contract (written in Solidity) defines the operations of the wallet described in the sections below. After the smart contract is deployed by owner's account, an ONE Wallet belonging to the user is created with a zero balance. The wallet can be funded by transferring funds to the deployed smart contract's address. The security parameters of the wallet are provided as part of the constructor of the smart contract at the time it is deployed. The security parameters includes but are not limited to: (1) the expected root hash(es) of the OTP Merkle Tree(s) and lifespan of the OTPs; (2) the daily spending limit(s); (3) the last-resort address which the funds should be drained to, in case of an account recovery; (4) whether enhanced security modes should be activated.

The Smart Contracts are organized by modules:

- Basic Wallet
    - Daily Spending Limit
    - Drain to Last Resort Account
- Guardians
- Enhanced Security Mode
    - Private-key based authorization
    - Counter-based OTP
    - Deferred execution
- (Coming soon) Social Identities
    - Twitter
    - Telegram


### Operations

#### Creating Wallet

#### Transfer Funds

##### Small Transfer

##### Large Transfer

#### Guardian

##### Add

##### Remove

#### Drain Funds

#### (TODO) Social Authentication

### Security

### Open Problems

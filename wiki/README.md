**DRAFT v0.0.10** | 2020-05-16

[1-Page Project Summary](http://harmony.one/1wallet)

[Demo & Code](https://github.com/hashmesan/harmony-totp)

[Harmony's Wallet Strategy](https://twitter.com/stse/status/1390810619834638336)

[Reference & Discussion](https://docs.google.com/document/d/1Ojyjm1MDT3CPHCOw36pCUQTSyRVdTI8XnEOb0m1VZkk/edit#heading=h.sbj5y85h1hg8)


## Table of Contents

* [Overview](#overview)
* [Technical Background](#technical-background)
    * [Challenges with Two\-factor Authentication (2FA) on Blockchain](#challenges-with-two-factor-authentication-2fa-on-blockchain)
    * [SmartOTP](#smartotp)
        * [Key issues for adoption](#key-issues-for-adoption)
        * [Notations](#notations)
        * [Assumptions](#assumptions)
        * [Security](#security)
* [ONE Wallet Technical Design](#one-wallet-technical-design)
    * [Context](#context)
    * [Components](#components)
        * [Client](#client)
            * [OTP Seed](#otp-seed)
            * [OTP](#otp)
            * [OTP Merkle Tree](#otp-merkle-tree)
            * [OTP Proof](#otp-proof)
            * [Visibility of OTP Merkle Tree](#visibility-of-otp-merkle-tree)
            * [Composable Authentication](#composable-authentication)
        * [Authenticator](#authenticator)
            * [OTP Seed](#otp-seed-1)
            * [OTP](#otp-1)
        * [Smart Contract](#smart-contract)
            * [Basic Wallet](#basic-wallet)
            * [Guardians](#guardians)
            * [Composable Authentication](#composable-authentication-1)
                * [Authentication with Private Key](#authentication-with-private-key)
                * [Authentication with HOTP](#authentication-with-hotp)
    * [Operations](#operations)
* [Security Analysis](#security-analysis)
* [Open Problems](#open-problems)


## Overview

ONE Wallet is a non-custodial crypto wallet optimized for everyday use cases. It is designed to be more secure and easier to use than existing crypto wallets and engineered to be more resilient to theft and accidental loss. Users can send payments as efficiently and securely as Venmo, Paypal, or Coinbase Wallet, and recover funds when they forget passwords. However, as a non-custodial wallet operating on smart contracts, the user would retain all control rather than being forced to trust a company or a person and give up all control to them.

ONE Wallet is one of the first non-custodial wallets to support Google authenticator, social recovery, and multi-layer authentication. The wallet will support major cryptocurrencies such as ETH, ONE, BSC, BTC, ATOM, and others. By design, the wallet requires two-factor authentications for sensitive operations. The funds in the wallet remain safe even if hackers gained control of a single device (e.g., wallet client on a computer). If the user loses their passwords or private keys, the wallet provides multiple mechanisms for fund recovery.

Features:

- Smart-contract wallet: open-source, transparent, entirely controlled by the user, using algorithms audited by the community.
- Establish ownership by social identities (e.g., Twitter), not just private keys
- Multiple layers of security (optional):
    - **Quick transfer**: Send a small amount of fund (e.g., $100) using a random 6-digit code generated by Google Authenticator
    - **Spending limit**: Control spending with a daily limit
    - **Fund recovery**: Set the last resort address for fund recovery so you would not lose all your funds even in the worst case
    - **Guardians**: Invite others to guard your wallet: establish identities, recover accounts, authorize sensitive transactions
    - **Multi-factor authentication**: Authorize sensitive operations (e.g., sending $100000, destroy wallet, adding/removing identities) using multiple mechanisms together (e.g., Twitter + Google Authenticator code + Guardian)

ONE Wallet runs on Harmony network, a fast blockchain based on proof-of-stakes consensus. It is compatible with apps that run on Ethereum, but substantially outperforms Ethereum in many ways (most significantly, fees and consensus time).

## Technical Background

### Challenges with Two-factor Authentication (2FA) on Blockchain

After two decades of security incidents, password leaks, and privacy movements, two-factor authentication and one-time password (OTP) already became ubiquitous in non-blockchain applications. Today, an app that does not have 2FA implemented may be considered insecure and look out of place. Among 2FA implementations, Google Authenticator (GA) is arguably the most popular method for generating an OTP (aside from sending OTP by text messages). With GA, a 6-digit code<sup>[1](#f1)</sup> OTP is generated using the current timestamp and a secret seed. The code remains valid for 30 seconds, aftwards a new code is generated. The seed is typically generated and stored by the app's server, displayed on the screen as a QR code, then transmitted by the user to the GA app by a camera scan. The QR code encodes the seed itself and some configuration parameters. The seed is permanently stored on GA and can be exported by the user at any time. The server can validate a user's identity by verifying whether the user is providing an expected QR code.

On a public blockchain, the role of a server is replaced by the smart contract, where the execution code and parameters are visible to the public by default. Therefore, we can no longer store the secret seed can on-chain. Otherwise, the seed would be visible to everyone. The challenge is to find a way to verify an OTP is valid at a given time without exposing any secret while assuming all execution data are visible to attackers. On top of that, the design must consider potential delays in blockchain consensus and blockchain's execution and storage cost.

<a name="f1">[1]</a> Although the iOS version supports 8-digit code, more secure algorithms, and additional options such as generating a new-code every 60 seconds instead of 30 seconds, the Android version only supports the most basic algorithm with 6-digit code. See an [in-depth analysis by Laban Sk√∂llermark](https://labanskoller.se/blog/2019/07/11/many-common-mobile-authenticator-apps-accept-qr-codes-for-modes-they-dont-support/)

### SmartOTP

Our design extends from the groundwork laid by [SmartOTP (Homoliak et al., 2018)](https://arxiv.org/abs/1812.03598). SmartOTP proposes a smart contract wallet that requires each operation to be confirmed by two factors: a signature generated by a private key (to initiate the operation) and an OTP generated by an authenticator. The signature-confirmation component is similar to how users authorize transactions on mainstream wallets (e.g., MetaMask). The OTP component is new, and it may be the first to explore the use of OTP in the context of a smart contract without using any oracle. Compared to MetaMask, the OTP mechanism adds an extra layer of security. In practice, it is cumbersome to ask the users to confirm every operation. Something as trivial as paying \$20 to a friend for lunch should be frictionless.

#### Key issues for adoption

Overall, there are several major obstacles in adopting SmartOTP:

1. The OTP is not a time-based OTP similar to that of Google Authenticator. Generating an OTP requires an operation ID as an input parameter instead of the current time.
2. The OTP is very long (at least 128-bit, compared to 20-bit for a 6-digit code in Google Authenticator).
3. The authenticator computes the OTP based on a customized function of the input (the operation ID and the seed). [*](#issue-beta-function)
4. All operations must be initiated using a signature confirmation, marked as pending, then later confirmed by the OTP.
5. A separate hardware wallet is assumed to carry the private keys and perform signing (and authorization) of the initialization of an operation.

#### Notations

Using the notation in the paper, we have: a user **U**, a client-side program **C** (similar to MetaMask), a hardware wallet **W** (similar to Trezor), and the smart contract wallet **S** (the smart contracts holding the user's funds and perform a variety of operations). The hardware wallet maintains the private key and produces signatures for all transactions. For our use case, we consider the client **C** merged with the hardware wallet **W**, and refer them both together as **C**.

#### Assumptions

Following the assumptions in SmartOTP:

1. The secret seed for OTP is only stored and kept on the authenticator **A**.
2. The client keeps a copy of the seed only before creating the smart contract wallet **S**.
3. When the wallet is created, the client generates a large number of OTPs with seed. These OTPs are then hashed and built into a Merkle tree<sup>[2](#f2)</sup>. The hashed values are kept in client **C** only. They will be used in computing proofs for operations. The seed is discarded after the wallet is created.
4. The smart contract wallet **S** only keeps the root<sup>[3](#f3)</sup> of the Merkle tree created in (3). The roots are sufficient to verify whether an OTP is valid.

<a name="f2">[2]</a>: The paper also introduces several optimizations to reduce the number of hashes by several orders of magnitudes. As discussed below, they cannot be used with Google Authenticator, so we omit the details here.

<a name="f3">[3]</a>: The paper suggests caching a layer of nodes to reduce the compute cost in practice. This optimization is not essential in our use case as the gas cost on Harmony network is cheap.

#### Security

Under the above assumptions, SmartOTP offers excellent security. SmartOTP remains secure when only a single point is compromised. A compromised client cannot confirm any operation without the correct OTP. A compromised authenticator does not pose any risk because the attacker cannot initiate any operation without the private key at the wallet (or client, in the absensce<sup>[4](#f4)</sup> of hardware wallet). We omit the details since the paper provides excellent analysis for various scenarios, such as attacks intended to prevent the user from accessing the funds.

<a name="f4">[4]</a>: If the client is compromised and a software wallet is used (as part of the client), the attacker may still perform a front-running attack.


## ONE Wallet Technical Design

The core of ONE Wallet is the client **C** and the smart contract **S**. A proof-of-concept (work in progress) is made open source and [available on Github](https://github.com/hashmesan/harmony-totp). The authenticator is Google Authenticator. At this stage, we are leaving the design of the user interface and wrappers around the client **C** to the next stage of the project. We are open for other developers to contribute, or to build their own wallet based on our core.

### Context

Since ONE Wallet is based on a smart contract, it has to be deployed (thus created) by another account. This operation costs gas, and the gas has to be paid by that account. We refer to that account as the owner account **O**. The owner account can be an existing wallet under the user's control, or a contract account created by Harmony specifically designated for this purpose. In either case, we assume it already exists. If it is an account under the user's control, the user may use it for fund recovery. For example, the user may add owner account's address as a guardian or as a last-resort drain. The user may also use it to add an extra layer of security, since the owner account would have its own private key **P** which can be used to sign transactions and initiate operations similar to the design in SmartOTP.

At the next stage of development, we may generate and manage this wallet address on the user's behalf. But for now, we focus our discussion and analysis only on the client **C**, the smart contract **S**, and how the user **U** interact with them using their Google Authenticator **A**. We also limit our initial discussion and security analysis to the authentication and authorizations provided by authenticator **A**, as well as private key **P** and guardians in applicable scenarios. We will leave social login features to the next version. To address security concerns and issues identified in previous sections, we also introduce Composable Authentication which makes uses of multiple OTPs and counter-based OTPs, in addition to the default settings which only a single time-based OTP is used.

In the sections below, we first define the elements the wallet uses in its operations and refer back to the SmartOTP paper if a similar element is used in the design of SmartOTP. Afterwards, we show how each elemenet is used in operations between the user and the wallet.

### Components

#### Client

The Client is the primary interface which the user may create and manage their ONE Wallet. The Client can be a native program running on an operating system, a browser extension, or a mobile app. The Client is assumed to be not easily compromised, thus any credentials and non-public constructs stored at the Client is assumed to be secure unless an attacker specifically targets the Client.

The Client holds constructs that are necessary to perform operations on the ONE Wallet. Some constructs are transient (e.g. OTP Seed) and must be destroyed as soon as they serve their purpose. Some constructs may become visible to the public over time (e.g. OTP Merkle Tree). We assume constructs such as owner account's private key **P** (if applicable) exists outside the Client in the current version. In later sections, we analyze the scenarios separately: the Client is compromised, the private key **P** is comrpomised, or both are compromised.

##### OTP Seed

OTP Seed is a random string generated by the Client and encoded in the QR code which is subsequently scanned by the user to initialize the Google Authenticator. The seed is destroyed after hashed values of potential OTPs are computed, **prior to** the creation of the wallet. Based on [RFC4226](https://www.ietf.org/rfc/rfc4226.txt) the secret seed must be at least 128-bit (16 characters long). The recommended length is 160-bit. In ONE Wallet we uses a random string of 160-bit long (20 characters).

Note that, in SmartOTP paper, the seed is generated by the Authenticator instead of the Client, and copied to Client in some air-gapped manner via QR Code (displayed on the authenticator) or a microSD card. We changed this mechanism because Google Authenticator cannot generate seed values on its own, and such change does not make the wallet less secure. If the Client is compromised during the creation of the wallet, the wallet would be compromised regardless of where the seed is generated.

##### OTP

OTP codes are generated and temporarily held at the Client only during the construction of OTP Merkle Tree, using exactly the same algorithms<sup>[6](#f6)</sup> the Authenticator would use. During OTP code generation, we enumerate possible input values (time or counter) for the OTP algorithms for a reasonably long foreseeble future. After the OTP Merkle Tree is generated, the OTPs are destroyed. The OTP codes themselves cannot be recovered from the Merkle Tree aside from using brute-force attacks. Since brute-force attacks on 1 million possible codes is trivially simple, if the OTP Merkle Tree is constructed using hashes of single OTP codes as leaves, the original OTP codes would be trivially recovered from the OTP Merkle Tree. In this scenario the OTP codes would not be able to offer an additional layer of security protection if the Client is compromised, sine the OTP Merkle Tree (see below) is stored in the Client. Nonethless, such OTP codes can still be useful in making small transfer convinient. See later sections for a detailed discussions. Additionally, our designs in the Composable Authentication address this issue by grouping multiple OTPs together before they are hashed and used as leaves, thus makes brute-force attacks exceedingly difficult.

<a name="f6">[6]</a>: A [mathematical construction](https://www.wikiwand.com/en/HMAC-based_One-Time_Password) is provided on Wikipedia. A [step-by-step tutorial with code examples](https://hackernoon.com/how-to-implement-google-authenticator-two-factor-auth-in-javascript-091wy3vh3) are available at Hackernoon.

##### OTP Merkle Tree

OTP Merkle Tree is a merkle tree constructed using hashed values of all the OTP codes enumerated for the expected lifespan of the wallet. The construction process is same as a standard merkle tree: the hashed values of the enumerated OTP codes are placed as the leaves of the tree, and the inner nodes of the tree are the hash of the concatenation of the consecutive hash pair from the layer below, starting from the leaves.

##### OTP Proof

OTP Proof is a path from a leaf to the root of the OTP Merkle Tree, plus an OTP code itself. In SmartOTP, the OTP Merkle Tree is not assumed to be secret. The OTP Proof is submitted to the Smart Contract as part of the proof during OTP validation. This implies whenever an OTP is used in an operation submitted to the blockchain, its sibling and ancestors on the merkle-tree are exposed to the public. Since SmartOTP's custom Authenticator re-uses all OTP codes for multiple times (while maintaining security by leveraging hashchains), the OTP Merkle Tree is completely made public soon after all OTP codes are used at least once.

##### Visibility of OTP Merkle Tree

In our design, the OTP Merkle Tree is not necessarily made public. This is because of two key differences: (1) the OTPs generated by Google Authenticator are time-based, and (2) the OTPs are never re-used. Since each OTP code is valid for 30 seconds, we only need to generate about 1 million<sup>[7](#f7)</sup> codes to cover an one-year lifespan of a wallet. In all but the most extreme corner use cases, the user would not be using the wallet all the time during the lifespan of the wallet, hence only a very small portion of the 1 million OTP codes would be used. Since time monotonically increases, and we are unable to embed a custom function in the Authenticator (as mentioned in [previous section](#issue-beta-function)), we would not be following any pattern to reuse a OTP code that was used in previous operations<sup>[8](#f8)</sup>.

At any time an OTP Proof is submitted as proof and made public, only its immediate sibling and ancestors are made public. This means all other values on the leaves (i.e. the hashes of the OTPs) would remain undisclosed until a corresponding OTP or its sibling's corresponding OTP is used. Therefore, we may assume the OTP Merkle Tree is semi-private, and leverage this property in our design. For example, we may create a "shallow copy" of the wallet offering limited functionalities to be used in an insecure environment (e.g. work phone, work laptop, family-shared computer), by providing a copy of the OTP Merkle Tree and allow some operations to be authorized by using the tree and an OTP code.

<a name="f7">[7]</a>: 3600 seconds / 30 seconds * 24 hours/day * 365 days/year ~= 1 million codes / year

<a name="f8">[8]</a>: Collision to previously used code would still occur, since there are only 1,000,000 codes available for a 6-digit OTP code. However, such collision would not be based on any tractable pattern.


##### Composable Authentication

In Composable Authentication, we use one or more additional counter-based OTP Seeds to configure the Authenticator, and generate associated OTP Merkle Tree accordingly. Different security levels may require different numbers of conseuctive OTPs to be provided to confirm a transaction. Thus, the OTPs must be first grouped together into n-tuples before being hashed and used as the leaves to generate the Merkle Tree, where n is the number of consecutive OTPs required.

#### Authenticator

As discussed above, the Authenticator we use is a standard Google Authenticator that can be downloaded from [iOS](https://apps.apple.com/us/app/google-authenticator/id388497605) and [Android](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en_US&gl=US) stores. Because of the compatibility issues<sup>[1](#f1)</sup> described above in the Android version of the Google Authenticator, we limit the configuration parameters<sup>[9](#f9)</sup> to using 6-digit OTP code, SHA1 hash function, and time-based OTP code with a refreshing interval of 30-seconds.

Despite the shortcomings, both Android and iOS version of the Google Authenticator also support counter-based OTP code. Although our design is primarily based on time-based OTP codes, in later parts we also use counter-based OTP codes to enhance its security. When counter-based OTP codes are used, we will need to add additional OTP seed to the Authenticator by scanning additional QR codes.

<a name="f9">[9]</a>: See Google Authenticator [URI format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format) for a detailed description of possible parameters. The QR Code simply encodes the URI.

##### OTP Seed

The Authenticator acquires the OTP seed from the Client when a new wallet is created, by scanning a QR code which also conveys other configurations for the Authenticator. The seed is then permanently stored on the Authenticator until the user manually deletes it.

It should be noted that Google Authenticator allows the user to export the seed at any time. Therefore, we need to consider two kinds of threats in our security analysis: (1) an attacker who gains visibility into one or more OTP codes, and (2) an attacker who temporarily gains physical or remote access to the user's phone, therefore is able to gain visibility into the OTP seed itself.

In Composable Authentication, counter-based OTPs are used in addition to time-based OTP. Extra OTP seeds  is stored on the Authenticator and the same analysis applies.

##### OTP

After the Authenticator is provided with OTP seed(s), the standard time-based OTPs are automatelly generated by Google Authenticator every 30 seconds (with an initial offset so to round off to nearest 30-second interval with respect to Unix epoch).

The counter-based OTPs used in EComposable Authentication are generated only by request from the user (by clicking a refresh button). The OTPs do not expire or refresh themselves, but they are automatically masked by Google Authenticator after a period of inactivity. Under the hood, each time the user refreshes the counter-based OTP, the counter is increased by one. The counter value is a private state inside the Authenticator. Since the user may refresh for an arbitrary number of times, the counter value may be different from what the Client and the Smart Contract anticipates. Therefore, the Client must look ahead and resynchronize<sup>[10](#f10)</sup> its own counter as well as the Smart Contract's, such that all three components would have consistent view of the counter value while verifying the OTP codes. This can be achieved easily at the Client since it possesses the hashed values of (groups of) OTPs (as part of the OTP Merkle Tree stored at the Client), and it may simply look ahead the hash values one-by-one and increment its internal counter until it finds a hash value that matches the hash of the OTP(s) provided by the user. Afterwards, the Client can submit the new counter value to the Smart Contract to achieve resynchronization at the Smart Contract.

<a name="f10">[10]</a>: See also a brief discussion in [RFC4224 Section 7.4 Resynchronization of the Counter](https://datatracker.ietf.org/doc/html/rfc4226#section-7.4)

#### Smart Contract

The Smart Contract (written in Solidity) defines the operations of the wallet described in the sections below. After the smart contract is deployed by owner's account, an ONE Wallet belonging to the user is created with a zero balance. The wallet can be funded by transferring funds to the deployed smart contract's address. The security parameters of the wallet are provided as part of the constructor of the smart contract at the time it is deployed. The security parameters includes but are not limited to: (1) the expected root hash(es) of the OTP Merkle Tree(s) and lifespan of the OTPs; (2) the daily spending limit(s); (3) the last-resort address which the funds should be drained to, in case of an account recovery; (4) whether Composable Authentication should be activated.

The Smart Contracts are organized by modules:

- Basic Wallet
    - Daily Spending Limit
    - Drain to Last Resort Account
- Guardians
- Composable Authentication
    - With Private Key
    - With Counter-Based OTP (HOTP)
- (Coming soon) Social Identities
    - Twitter
    - Telegram

##### Basic Wallet

The Basic Wallet contract aims for simplicity, so new users can onboard quickly. It provides implementations to complete everday wallet operations with the least amount of frication. As such, operations defined in the Basic Wallet do not require two-factor authentications unless they exceed some limits set by the user, such as daily spending limit and per-transaction transfer limit. In absence of user-defined limits, a set of default limits are applied.

The Basic Wallet contract defines:

- Mechanisms for creating a wallet and default parameters
- Functions for validating OTP codes given an OTP Proof
- Process of initiating and completing an operation given a time-based OTP code and its OTP Proof
- Constraints and execution steps for transfering funds
- Fund recovery and wallet destruction processes

The Basic Wallet maintains the states of:

- Daily spending limits
- Activation statuses of Guardian and Composable Authentication modules

Unlike SmartOTP, operations (under limits) on the Basic Wallet do not start with a "pending" state, before they transition into a "confirmed" state by separate routines that validate OTP Proofs (including OTP codes). Transfers are subject to a small daily spending limit until the user has at least one guardian, at which time the daily spending limit would be lifted to a medium-sized value. Larger daily spending limits require the activation of Composable Authentication.

A transfer can be initiated and completed within the same function call by providing only a valid OTP Proof, unless the total amount transferred within the last 24 hours exceeds the aforementioned medium-sized value. In the later case, the transfer would be processed by Composable Authentication module, where operations would begin with a "pending" state, and confirmed only when a required level of authentications is met.

The daily spending limits and transfer limits for "small", "medium" and "larger" sizes are defined by the user at the time when the wallet is created. By default, the limits are set to the following. All USD amounts are converted to equivalent number of ONE computed at the Client by using 24h average exchange rate of ONE-USDT on Binance.

- Small daily spending limit: \$500 USD
- Medium daily spending limit: \$5000 USD
- Larger daily spending limit: above \$5000 USD

##### Guardians

Guardians are other wallet accounts and users. They are wallet accounts designated by the user to protect the funds in the wallet. This includes offering one layer of security and authorizing legitimate transactions, alert the user and defer operations when the Guardian notices suspicious activities, and help a forgetful user recover their funds after they lose access to their own account.

The Guardian contract defines how guardians are added, removed, and validated. The contract also defines how Guardians may:

- initiate a recovery operation and drain funds to the last resort account
- authorize activation of Composable Authentication
- (Composable Authentication) serve as one authentication factor to increase spending limits
- (Composable Authentication) confirm to deactivate Composable Authentication

The only state the contract maintains is the list of addresses for the guardians.

##### Composable Authentication

Composable Authentication provides more authentication factors that can be composed together. This allows sensitive operations to set different number of factors required to confirm the operation, thus achieving different levels of security protection.

At this time, Composable Authentication contracts provide two additional authenticaation factors: (1) private key, and (2) counter-based OTP (HOTP). In Composable Authentication contracts, operations (such as transfer) remain pending until they are confirmed by one or two factors of authorization, or abandoned (expired). The contract maintains the states of pending operations, and the activation statuses for each authentication factor.

Composable Authentication must be activated if the user wants to increase the daily spending limit to a larger amount (above \$5000, by default). Otherwise, Composable Authentication is completely optional. Composable Authentication can be activated at any time by the user. If the user already has at least one guardian, activating Composable Authentication would require both a guardian's confirmation and the correct OTP Proof.

Once activated, Composable Authentication can only be deactivated by one of the following methods:
(1) Confirmations from all guardians, plus at least one authentication factor activated by the user in Composable Authentication.
(2) All factors of authorization, activated by the user in Composable Authentication. If the user has a guardian, at least one confirmation from guardians.

The daily spending limit may be further increased using Composable Authentication to "Large" or "No Limit" (for 24 hours).

- Large daily spending limit \$25000 USD: requires confirmation from at least one factor using Composable Authentication.
- No limit for 24 hours: requires confirmation from either:
    - Two factors using Composable Authentication, or
    - One factor using Composable Authentication, and one confirmation using Guardian

The daily spending limit can also be decreased down to "Large" (\$25000), "Medium" (\$5000), "Small" (\$500), or "Zero" (\$0), using confirmation from at least one factor using Composable Authentication, or confirmation from a Guardian.

In all above operations, standard time-based OTP Proof from Basic Wallet is still required to initiate the operations. The confirmation required by Composable Authentication may only confirm operations already initiated, but not to initiate new operations.


###### Authentication with Private Key

Authentication with Private Key behaves similar to the use of private keys in SmartOTP, but with a few differences.

In SmartOTP, an operation must be initiated by providing a signature for the transaction, signed using owner account's private key. The operation is held on the smart contract as pending, until it is later confirmed by the client using an OTP Proof. In SmartOTP's design, the signature is produced by a hardware wallet (which possesses the private key). The hardware wallet is assumed to secure.

Here, we do not use the signature to initiate an operation. The signature is used confirm an operation that is already pending (and initiated using an OTP Proof). SmartOTP enforces a rule that all operations must be initiated using the correct signature. Here, we do not enforce the rule. Any address on the network can initiate an operation on the wallet, using the correct OTP Proof.

There are several reasons for this change:

1. We aim for high usability. Only a subset of operations require higher security protection, thus two-factor (or more) authentication. The majority of operations are initiated by the Client using only OTP Proof. It would confuse the user to require a small subset of operations to be initiated by private key signatures.
2. This change does not make the wallet less secure as long as the device holding the private key is different from the device running the Client. The transaction is still protected by at least two factors. If the Client is compromised, the attacker may initiate transactions but not to confirm them. If the private key is compromised, the attacker cannot do anything because no operation can be initiated using the private key.

To elaborate, in our use case the device holding the private key does not need to be a hardware wallet, and the signature does not need to be transmitted by the client. Any program may transmit the signature and confirm the pending operation, as long as (a) it has the ability to store the private key securely; (b) it has the ability to sign a transaction given the transaction's parameters; (c) it has the ability to send a message to the smart contract wallet on Harmony network via RPC calls. As discussed above in (2), it would be best for the program to be on a separate device than the client, so they would not be compromised at the same time. For example, if the client is running as a browser extension on a desktop computer, the device holding the private key can be a simple mobile private-key based wallet, or a browser/desktop wallet on a different laptop computer.

Authentication with Private Key can be activated in Composable Authentication contract, using a function that takes parameters of (1) the public key of the signer, and (2) the usual OTP Proof to initiate operations, and (3) The OTP Proof for Authentication with HOTP, if it is already activated.

In practice, the public key can be transmitted between devices using a QR code, or by simply copying and pasting. After obtaining the public key, the client can call the function in the Composable Authentication contract with the required parameters.

###### Authentication with HOTP

Authentication with HOTP (i.e. counter-based OTP) allows operations to be confirmed by providing an extra OTP Proof. It behaves similar to standard time-based OTP as described in preceding sections and the SmartOTP paper. The difference here is the OTP Proof and OTP Merkle Trees are computed using a tuple of 3 counter-based OTP codes<sup>[11](#f11)</sup> concatenated together.

During activation, a new OTP Seed is generated. The user is provided with a configuration QR-code for counter-based OTP, which the user must scan to add to Google Authenticator as a separate entry to the time-based OTP. The construction of the OTP Merkle Tree is same as the process in time-based OTP, except the OTP hashes are computed using tuples of 3 consecutive OTPs concatenated together.

In counter-based OTP mode, Google Authenticator allows the user to refresh and skip an arbitrary number of OTPs. Therefore, when the user provides a tuple of 3 consecutive OTPs, there may be an offset of 0, 1, or 2 depending on how many they skipped. Since the number of skips is unknown to us and not tracked by Google Authenticator, we must account for all possible offsets. To do this, we must compute 3 OTP Merkle Trees, skipping the first 0, 1, 2 OTPs generated respectivefully, before grouping the OTPs into tuples of three, and hash the tuples and use them as leaves. This allows us to search in the list of leaves from each tree, to find which one aligns with the tuple provided by the user. To achieve this, we construct the OTP Proof in a manner identical to the process of computing OTP Proof with time-based OTP, except 3 consecutive OTPs are taken and concatenated before it is hashed and used to construct the proof. We may use the hash to find which OTP Merkle Tree the tuple corresponds to and to resynchronize the counter, by simply looking ahead (for a large but finite window size) using the list of the leaves for each OTP Merkle Tree, and stop at the first match.

Authentication with HOTP can be activated in Composable Authentication contract using a function requires parameters of (1) the root hashes for all 3 OTP Merkle Trees (computed by the client<sup>[12](#f12)</sup>), and (2) the usual time-based OTP Proof to initiate operations.

Operations can be confirmed using Authentication with HOTP by providing the OTP Proof computed by the client (based on 3-OTP tuple provided by the user), an updated counter-value to resynchronize the counters (to account for number of OTPs skipped by the user) and an integer value indicating which of the 3 OTP Merkle Trees are used.

<a name="f11">[11]</a>: This represents 60-bit security, since each OTP 6-digit code provides 20-bit of security. On Stackoverflow, an answer to the question ["How reassuring is 64-bit (in)security?"](https://crypto.stackexchange.com/questions/63536/how-reassuring-is-64-bit-insecurity) provides an analysis for the cost to brute-force the pre-image of the hash using generic hardware. An attack is possible by first compromising the client to obtain the OTP Merkle Trees, then finding a hashed value in the leaves that is sufficiently ahead of the current counter, then computing the 3-OTP tuple by brute-force. However, such attack is unlikely to be worth the effort and the cost. We may also adjust the number of consecutive OTPs from 3 to 4 or 5 for users who require extra security protection. We may also provide 5-OTP as a separate factor of authorization.

<a name="f12">[12]</a>: If we use the same client which computes the time-based OTP Proof and the client is compromised, technically the attacker may intercept the OTP codes and front-run any operation. For extra security, we may advise the user to use a client on another device to complete Authentication with HOTP. In practice, it may be cumbersome and it might be the case that only a small portion of users may elect to do that.

### Operations

See [Smart Contract References](https://github.com/polymorpher/one-wallet/wiki/Smart-Contract-Refnereces)

## Security Analysis

TODO

## Open Problems

TODO
